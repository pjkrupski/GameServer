

Web Server Specification
--------

**HTTP:** 

Our core HTTP code will have to conform to the following specifications so that it may be used to serve our front end application to real clients.

1. Our HTTP server will be compliant to a subset of the the HTTP 1.1 standard for the `GET` and `POST` verbs.

 Compliance will be measured through a close read of the standard itself as well as real world testing. For example, our server will be able to field requests from every major browser as well as requests generated by the  `curl` command line tool.
 
 
2. Our HTTP server will accept any combination of standard and non standard headers. In addition, requests containing "URL Encoded" strings will be handled properly.

 For example, a request to a URL of `http://domain.com/my%20image.jpg` will return the file named `my image.jpg`. 
 
 No limits on the number of headers will be put in place, as no limits are present in the HTTP standard.

3. The serving of non text based files and MIME types (images, ...) will be accomplished and appropriate headers indicating the MIME type of the response will be included.

 When our frontend requests an image to display as part of a webpage, server will respond with the correct MIME type and format, allowing all browsers to include the image as normal on screen.

4. Cache control headers will be accurate when serving cached data.

 When clients request a static asset such as an image, our server will appropriately mark this to be cached. Verifying this is as simple as ensuring that our server does not receive repeat requests from users for the same asset while their cache is still valid.

**Framework:**

Around our low level HTTP code, we will create a feature rich web framework that will serve as both a reusable backend for others as well as the backend for our game.

1. Our backend needs to be able to handle concurrent requests. Without this capability, all clients will be forced to wait while other requests are being processed. For example, clients issuing `POST`s should not have to wait behind a client requesting a large image.
 
 Leveraging Java's native `Thread` primitive, we will parallelize the serving of requests, essentially untangling clients from eachother.
 
2. For a small number of static files (javascript, html, css), heavily requested assets will be stored in memory and served via a cache. Exposing this functionality will be a core part of the framework and will improve performance of repeated accecsses. 

3. Paramaterized routes will be used to handle complex requests that convey meaning. For example, a request to `/room/123/leave` would indicate that a user would like to leave a given room. This can be realized with a route like `"/room/{number}/leave"` which would then pass in the user provided value of `{number}` to the appropriate callback.

4. Ergonomic handling of requests and responses will be provided to users of the framework via an "Express-like" synatx (express being the popular web server for node.js). For example, `server.get("/room/{number}/leave", (req, res) -> { ... })`